# スケジュール管理アプリ開発 議事録（続き）

**日付**: 2026-02-02

---

## 質問

GitHub Pagesとして静的サイトとして運用する場合の以下懸念について教えて下さい
・アクセスへの認証はどうなるか
・GitHub Pagesで公開する場合、スケジュール情報について、同リポジトリ内にYaml形式等でおいた情報を元に描画することがぱっと思い浮かんでいます（バックエンドでの検索機能がなくても読み込んだ情報からフロントのみで検索等での絞り込みは可能な認識）が他に良い方法はありますか

---

## 回答

良い質問です。GitHub Pagesを使う場合の重要なポイントを整理します。

### 1. アクセスへの認証について

#### GitHub Pagesの制約
- **基本的に誰でもアクセス可能**（認証なし）
- プライベートリポジトリでも、GitHub Pagesのサイト自体は公開される
- GitHub Enterprise利用時のみ認証付きページが可能（有料）

#### 認証を実装する方法

##### オプションA: クライアントサイド認証（簡易）
- JavaScriptでパスワードチェック
- **セキュリティは低い**（ソースコードでパスワードが見える可能性）
- 個人利用で十分な場合のみ

##### オプションB: 外部認証サービスを使用
- **Firebase Authentication**（おすすめ）
- **Auth0**（無料枠あり）
- **Supabase Auth**

##### オプションC: 完全にローカルで動作（認証不要）
- データはブラウザ内にのみ保存
- 外部に公開されない
- **これが最もシンプル**

### 2. データ保存方法について

ここが重要なポイントです。**2つの異なるアプローチ**があります：

#### パターンA: 完全静的サイト（YAML/JSON管理）

```
リポジトリ構造例:
├── index.html
├── data/
│   └── schedules.yaml  # ← 予定データ
└── js/
    └── app.js          # フロントエンドで読み込み・表示
```

**特徴:**
- データはリポジトリ内のYAML/JSONファイル
- 予定の追加は**Git経由で手動編集**が必要
- ブラウザで「予定を登録」ボタンを押しても、リポジトリには保存できない

**メリット:**
- シンプル
- バージョン管理できる
- バックアップが自動

**デメリット:**
- **ブラウザから直接編集できない**
- 予定追加のたびにGit commit & pushが必要
- 一般的な「アプリ」としては使いにくい

#### パターンB: PWA（ローカルストレージ）

```
リポジトリ構造例:
├── index.html
├── manifest.json       # PWA設定
├── sw.js              # Service Worker
└── js/
    └── app.js         # IndexedDB/LocalStorageでデータ管理
```

**特徴:**
- データはブラウザ内のIndexedDB/LocalStorageに保存
- ブラウザから直接予定を登録・編集可能
- GitHub Pagesは**アプリの配布**のみに使用

**メリット:**
- 普通のアプリのように使える
- リアルタイムで予定追加・編集可能
- オフラインでも動作

**デメリット:**
- ブラウザデータ削除でロストのリスク
- エクスポート/インポート機能が必要

### おすすめの構成

**ご要件（予定の登録、メモの記録、検索）を考えると、パターンBが適切です。**

#### 推奨: PWA + GitHub Pages + エクスポート機能

```
データフロー:
1. GitHub Pages: アプリ本体をホスティング（静的ファイル）
2. ブラウザ: データはIndexedDBに保存
3. エクスポート: 定期的にJSON/YAMLでバックアップ
4. オプション: バックアップをGitHub Gistに自動保存
```

**実装例:**
```dart
// Flutter Webでの実装イメージ
// 1. データはHiveやIsarでローカル保存
// 2. エクスポート機能でJSONダウンロード
// 3. GitHub APIでGistに自動バックアップ（オプション）
```

### パターンAが適している場合

**J.LEAGUEの試合スケジュール表示**のような「自分で編集する必要がない」データなら、YAMLファイル管理が最適です。

```yaml
# schedules.yaml
matches:
  - date: 2026-03-01
    home: "浦和レッズ"
    away: "鹿島アントラーズ"
    stadium: "埼玉スタジアム"
  - date: 2026-03-08
    home: "FC東京"
    away: "横浜F・マリノス"
    stadium: "味の素スタジアム"
```

### どちらを選ぶべきか？

| 要件 | パターンA（YAML） | パターンB（PWA） |
|------|------------------|------------------|
| ブラウザから予定登録 | ❌ 不可 | ✅ 可能 |
| 認証不要で使える | ✅ 可能 | ✅ 可能 |
| データバックアップ | ✅ 自動（Git） | ⚠️ 手動 |
| オフライン動作 | ✅ 可能 | ✅ 可能 |
| 使いやすさ | ❌ 低い | ✅ 高い |

**結論: パターンB（PWA + ローカルストレージ）+ エクスポート機能を推奨します。**

どちらの方向で進めますか？それとも両方の要素を組み合わせた構成（例: 公式J.LEAGUE日程はYAML、個人メモはローカルストレージ）も検討されますか？

---

## 質問

データのバックアップと復旧が決め手になりますね。
エクスポート先はiOSデバイス内の任意のパス（ブラウザのローカルストレージとは別）になり、またそのパスを指定してバックアップデータの読み出しなども実装可能ですか？

---

## 回答

重要な質問です。**結論から言うと、iOS上のPWA（Webアプリ）では制限があります。**

### iOS上のPWAでのファイル操作の制約

#### できること ✅

##### 1. **エクスポート（ダウンロード）**
```
動作：
1. アプリ内で「エクスポート」ボタンをタップ
2. JSONファイルがダウンロードフォルダに保存される
3. ユーザーが手動でiCloud DriveやFilesアプリに移動可能
```

**保存先:**
- Safari: ダウンロードフォルダ（デフォルト）
- ユーザーが「ダウンロード」時に保存場所を選択できる場合あり（iOS 13以降）

##### 2. **インポート（ファイル選択）**
```
動作：
1. アプリ内で「インポート」ボタンをタップ
2. iOSのファイルピッカーが開く
3. ユーザーが手動でファイルを選択
4. アプリがファイルを読み込み
```

##### 3. **Share API（共有）**
```
動作：
1. 「共有」ボタンをタップ
2. iOSの共有シートが開く
3. iCloud Drive、メール、他のアプリに保存可能
```

#### できないこと ❌

##### 1. **特定パスへの自動保存**
- `"/Users/xxx/Documents/backup.json"` のような指定はできない
- ユーザーが毎回保存先を選ぶ必要がある

##### 2. **ファイルシステムへの直接アクセス**
- Filesアプリ内を自動的にスキャンしてファイルを探すことはできない

##### 3. **バックグラウンドでの自動バックアップ**
- ユーザーの操作なしに自動保存は不可

### iOS PWAでの実装可能な範囲

#### パターン1: 標準的な方法（推奨）

```dart
// エクスポート
void exportData() {
  final jsonData = convertToJson(schedules);
  final blob = html.Blob([jsonData]);
  final url = html.Url.createObjectUrlFromBlob(blob);
  final anchor = html.AnchorElement()
    ..href = url
    ..download = 'schedule_backup_${DateTime.now()}.json'
    ..click();
}

// インポート
void importData() {
  final input = html.FileUploadInputElement()..accept = 'application/json';
  input.onChange.listen((e) {
    final file = input.files!.first;
    final reader = html.FileReader();
    reader.onLoadEnd.listen((e) {
      final jsonData = reader.result as String;
      // データを復元
    });
    reader.readAsText(file);
  });
  input.click();
}
```

**ユーザー体験:**
1. 「バックアップ」ボタンをタップ
2. ファイルがダウンロードされる（保存先を選択可能）
3. 「復元」ボタンをタップ
4. ファイルを手動で選択
5. データが復元される

#### パターン2: iCloud Drive連携（半自動）

**Share API + ショートカット:**
```dart
// Share APIでiCloud Driveに保存を促す
void shareBackup() {
  final jsonData = convertToJson(schedules);
  // Web Share APIを使用
  html.window.navigator.share({
    'files': [/* File object */],
    'title': 'スケジュールバックアップ',
  });
}
```

**ユーザー体験:**
1. 「バックアップ」ボタン
2. iOSの共有シートで「iCloud Driveに保存」を選択
3. 次回から同じ場所を選びやすい

#### パターン3: クラウドバックアップ（最も確実）

**GitHub Gist（無料、認証必要）:**
```dart
// GitHub Personal Access Tokenを使用
// Gistに自動バックアップ
void autoBackupToGist(String token, String data) async {
  final response = await http.patch(
    Uri.parse('https://api.github.com/gists/{gist_id}'),
    headers: {'Authorization': 'token $token'},
    body: jsonEncode({
      'files': {
        'schedule_backup.json': {'content': data}
      }
    }),
  );
}
```

**メリット:**
- 完全自動バックアップ
- 任意のタイミングで復元可能
- バージョン履歴も保存

### File System Access API（将来の可能性）

**現状:**
- Chrome/Edge on Android/Desktop: ✅ サポート
- Safari on iOS: ❌ **未サポート**

**もしサポートされれば:**
```javascript
// 将来的な実装（iOSでは現在不可）
const handle = await window.showSaveFilePicker({
  suggestedName: 'backup.json',
  startIn: 'documents'
});
```

### 推奨する実装

#### **オプション1: ローカル + 手動バックアップ（シンプル）**
```
✅ ダウンロード/ファイル選択でエクスポート/インポート
✅ 実装が簡単
⚠️ ユーザーが手動で管理
```

#### **オプション2: ローカル + クラウドバックアップ（推奨）**
```
✅ 自動バックアップ（GitHub Gist/Firebase Storage）
✅ 複数デバイス対応も可能
✅ 手動エクスポートも併用
⚠️ 認証が必要（GitHub or Google）
```

#### **オプション3: Flutterネイティブアプリ**
```
✅ ファイルシステムへの完全アクセス
✅ 任意のパスに保存可能
✅ 自動バックアップ実装可能
❌ Apple Developer登録が必要（年$99）
❌ TestFlightまたは7日制限
```

### 質問への直接回答

> エクスポート先はiOSデバイス内の任意のパス（ブラウザのローカルストレージとは別）になり、またそのパスを指定してバックアップデータの読み出しなども実装可能ですか？

**回答: PWAでは不可能です。** ただし：

1. **ダウンロードフォルダへの保存** → ✅ 可能
2. **ユーザーによる保存先選択** → ✅ 可能（手動）
3. **任意パスの自動指定** → ❌ 不可能（PWA制約）
4. **手動でのファイル選択復元** → ✅ 可能
5. **クラウドへの自動バックアップ** → ✅ 可能（GitHub Gist等）

### 最終提案

スケジュール管理アプリなら、以下の組み合わせがベストです：

```
1. メインストレージ: IndexedDB（ブラウザ内）
2. 手動バックアップ: JSON/YAML ダウンロード
3. 自動バックアップ: GitHub Gist（オプション、要認証）
4. 復元: ファイル選択 or Gistから自動復元
```

この構成で進めますか？それとも、より確実なファイル管理のためにFlutterネイティブアプリを検討されますか？

---

## 質問

認証について、認証情報はGithubのSecretに格納しておいて比較し認証する実装は可能ですか

---

## 回答

重要な誤解があるので、正確に説明します。**GitHub Secretsを使った認証は、静的サイト（GitHub Pages）では実現できません。**

### GitHub Secretsの制約

#### GitHub Secretsとは
- **GitHub Actions（CI/CD）専用**の機能
- ビルド時にのみアクセス可能
- ランタイム（ブラウザでアプリ実行中）にはアクセス不可

#### なぜPWAで使えないか

```
ビルド時（GitHub Actions）:
✅ Secrets利用可能
  → ビルド処理、デプロイ処理に使用

ランタイム（ユーザーがブラウザでアクセス）:
❌ Secrets利用不可
  → ブラウザからGitHub Secretsは読めない
```

### 静的サイトでの認証の根本的な問題

#### 問題：すべてのコードが公開される

```javascript
// これは無意味（誰でも見える）
const PASSWORD = "my-secret-123";  // ← ソースコード見れば分かる

if (userInput === PASSWORD) {
  // 認証OK
}
```

**理由:**
1. GitHub Pagesは静的ファイルをそのまま配信
2. JavaScriptのソースコードは誰でも見れる（DevTools等で）
3. パスワードやトークンをハードコードしても意味がない

### 実現可能な認証方法

#### 方法1: GitHub OAuth（最も安全）

**仕組み:**
```
1. ユーザーが「GitHubでログイン」ボタンをクリック
2. GitHubの認証画面にリダイレクト
3. ユーザーがGitHubで認証
4. アプリに戻り、GitHubのアクセストークンを取得
5. そのトークンで自分のGitHub Gistにアクセス
```

**実装:**
```javascript
// Firebase AuthenticationでGitHub OAuth
import { signInWithPopup, GithubAuthProvider } from 'firebase/auth';

const provider = new GithubAuthProvider();
provider.addScope('gist'); // Gistアクセス用

const result = await signInWithPopup(auth, provider);
const credential = GithubAuthProvider.credentialFromResult(result);
const token = credential.accessToken; // ← これでGist操作
```

**特徴:**
- ✅ 安全（パスワードが外部に漏れない）
- ✅ 自分のGitHubアカウントのみアクセス可能
- ✅ Gistへの自動バックアップも可能
- ⚠️ GitHubアカウント必須

#### 方法2: Firebase Authentication（推奨）

**仕組み:**
```
1. メール/パスワードで登録
2. Firebaseが認証を管理
3. 認証後、Firebaseの機能を利用可能
```

**実装:**
```javascript
import { signInWithEmailAndPassword } from 'firebase/auth';

// ログイン
await signInWithEmailAndPassword(auth, email, password);

// データ保存（オプション：Firestoreを使う場合）
await setDoc(doc(db, 'users', uid, 'schedules'), data);
```

**特徴:**
- ✅ 安全（サーバーサイドで検証）
- ✅ メール/Google/Apple IDなど複数の認証方法
- ✅ 無料枠が大きい
- ✅ Firestore使えばクラウドバックアップも簡単
- ⚠️ Firebase設定が必要

#### 方法3: 簡易パスワード認証（非推奨だが可能）

**仕組み:**
```javascript
// ハッシュ化されたパスワードを比較
const HASHED_PASSWORD = "5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8"; // SHA-256

async function login(password) {
  const hashed = await sha256(password);
  if (hashed === HASHED_PASSWORD) {
    sessionStorage.setItem('authenticated', 'true');
    return true;
  }
  return false;
}
```

**特徴:**
- ⚠️ セキュリティは低い（ソースコードを見ればハッシュが分かる）
- ⚠️ ブルートフォース攻撃に弱い
- ✅ 実装が簡単
- ✅ 外部サービス不要
- **個人利用で「見られても困らない」データ向け**

#### 方法4: 認証なし（完全ローカル）

**最もシンプル:**
```
- 認証機能なし
- データはブラウザ内のみ
- 外部に送信されない
- 誰でもURLにアクセスできるが、データは見えない
```

**特徴:**
- ✅ 最もシンプル
- ✅ プライバシー保護
- ✅ セキュリティリスクなし
- ✅ 個人利用に最適

### GitHub Secretsを使う唯一の方法

**ビルド時に環境変数として埋め込む:**

```yaml
# .github/workflows/deploy.yml
name: Deploy
on: [push]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Build with secrets
        env:
          FIREBASE_API_KEY: ${{ secrets.FIREBASE_API_KEY }}
        run: |
          # 環境変数としてビルドに埋め込む
          flutter build web --dart-define=FIREBASE_API_KEY=$FIREBASE_API_KEY
```

**問題点:**
```javascript
// ビルド後のJavaScript（誰でも見える）
const firebaseConfig = {
  apiKey: "AIzaSyXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", // ← 見える
  // ...
};
```

**ただし:** FirebaseのAPI Keyは公開されても問題ない（Firebase Security Rulesで保護）

### 推奨する構成

#### パターンA: 完全プライベート（認証不要）
```
✅ GitHub Pages（アプリ配信）
✅ IndexedDB（データはローカル）
✅ JSONエクスポート/インポート
✅ 認証なし
```
**最適な用途:** 個人用、他人に見られても問題ないURL

#### パターンB: GitHub OAuth + Gist
```
✅ GitHub Pages（アプリ配信）
✅ GitHub OAuth（認証）
✅ GitHub Gist（データ保存）
✅ IndexedDB（ローカルキャッシュ）
```
**最適な用途:** GitHubユーザー、自動バックアップ必要

#### パターンC: Firebase
```
✅ Firebase Hosting（GitHub Pagesの代わり）
✅ Firebase Authentication（認証）
✅ Firestore（データ保存、オプション）
✅ IndexedDB（ローカル）
```
**最適な用途:** 将来的に機能拡張予定、複数デバイス同期

### 質問への直接回答

> 認証情報はGitHubのSecretに格納しておいて比較し認証する実装は可能ですか

**回答: 不可能です。**

理由：
1. GitHub Secretsはビルド時のみアクセス可能
2. ブラウザからGitHub Secretsにはアクセスできない
3. 静的サイトではサーバーサイド処理ができない

**代替案:**
- GitHub OAuth（GitHubアカウントで認証）
- Firebase Authentication（メール/パスワード認証）
- 認証なし（データをローカルのみに保存）

どの方法が良さそうですか？個人的には、**認証なし（パターンA）**が最もシンプルで、スケジュール管理アプリには十分だと思います。

---

## 質問

個人を特定するような情報ではないとはいえ、個人的なスケジュールなので認証なしは避けたいところですね。
提示された案からだと、
・方法3: 簡易パスワード認証（非推奨だが可能）
でまず初め、諸々の機能開発・検証を進め
最終的に
・方法1: GitHub OAuth（最も安全）
に進むのが良いと思いました

---

## 回答

非常に良い判断だと思います。段階的なアプローチで、まず動くものを作って検証し、後で強化するのは理想的です。

### 開発ロードマップ

#### フェーズ1: プロトタイプ（簡易パスワード認証）

**メリット:**
- ✅ 実装が簡単（1-2時間で実装可能）
- ✅ 外部サービスの設定不要
- ✅ スケジュール管理のコア機能開発に集中できる
- ✅ 「最低限の保護」は提供される

**実装例:**

```dart
// lib/services/simple_auth_service.dart
import 'dart:convert';
import 'package:crypto/crypto.dart';
import 'package:shared_preferences/shared_preferences.dart';

class SimpleAuthService {
  // 事前に生成したハッシュ（開発時に一度だけ生成）
  // パスワード "my-secure-password" のSHA-256
  static const String _passwordHash =
    '2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824';

  // ログイン状態を保存
  Future<bool> login(String password) async {
    final bytes = utf8.encode(password);
    final hash = sha256.convert(bytes).toString();

    if (hash == _passwordHash) {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setBool('isAuthenticated', true);
      await prefs.setString('sessionToken', _generateSessionToken());
      return true;
    }
    return false;
  }

  Future<bool> isAuthenticated() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getBool('isAuthenticated') ?? false;
  }

  Future<void> logout() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.clear();
  }

  String _generateSessionToken() {
    return DateTime.now().millisecondsSinceEpoch.toString();
  }
}
```

```dart
// lib/screens/login_screen.dart
class LoginScreen extends StatefulWidget {
  @override
  _LoginScreenState createState() => _LoginScreenState();
}

class _LoginScreenState extends State<LoginScreen> {
  final _passwordController = TextEditingController();
  final _authService = SimpleAuthService();
  bool _isLoading = false;
  String? _errorMessage;

  Future<void> _handleLogin() async {
    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    final success = await _authService.login(_passwordController.text);

    if (success) {
      Navigator.of(context).pushReplacementNamed('/home');
    } else {
      setState(() {
        _errorMessage = 'パスワードが正しくありません';
        _isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: Padding(
          padding: EdgeInsets.all(24),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text('スケジュール管理', style: TextStyle(fontSize: 24)),
              SizedBox(height: 32),
              TextField(
                controller: _passwordController,
                decoration: InputDecoration(
                  labelText: 'パスワード',
                  errorText: _errorMessage,
                ),
                obscureText: true,
                onSubmitted: (_) => _handleLogin(),
              ),
              SizedBox(height: 16),
              ElevatedButton(
                onPressed: _isLoading ? null : _handleLogin,
                child: _isLoading
                  ? CircularProgressIndicator()
                  : Text('ログイン'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
```

**パスワードハッシュの生成方法:**
```bash
# ターミナルで実行（開発時に一度だけ）
echo -n "your-password" | shasum -a 256
```

#### フェーズ2: 機能開発

簡易認証の実装後、以下の機能を開発：

1. 予定の登録・編集・削除
2. メモ機能
3. 検索機能
4. エクスポート/インポート機能
5. UI/UX改善

**この段階では認証周りを気にせず、コア機能に集中できます。**

#### フェーズ3: GitHub OAuth移行

機能が完成したら、認証部分だけを置き換え：

**実装例:**

```dart
// lib/services/github_auth_service.dart
import 'package:firebase_auth/firebase_auth.dart';

class GitHubAuthService {
  final FirebaseAuth _auth = FirebaseAuth.instance;

  Future<UserCredential?> signInWithGitHub() async {
    // GitHub OAuthプロバイダー作成
    GithubAuthProvider githubProvider = GithubAuthProvider();
    githubProvider.addScope('gist'); // Gist用

    try {
      final userCredential = await _auth.signInWithPopup(githubProvider);
      return userCredential;
    } catch (e) {
      print('GitHub認証エラー: $e');
      return null;
    }
  }

  Future<void> signOut() async {
    await _auth.signOut();
  }

  User? get currentUser => _auth.currentUser;

  bool get isAuthenticated => currentUser != null;
}
```

**移行時の変更点:**
```dart
// Before (簡易認証)
final _authService = SimpleAuthService();

// After (GitHub OAuth)
final _authService = GitHubAuthService();

// インターフェースを統一しておけば、切り替えが簡単
```

### 移行をスムーズにする設計

**認証サービスを抽象化しておく:**

```dart
// lib/services/auth_service_interface.dart
abstract class AuthService {
  Future<bool> login(String credential);
  Future<bool> isAuthenticated();
  Future<void> logout();
}

// 簡易認証版
class SimpleAuthService implements AuthService {
  // 上記の実装
}

// GitHub OAuth版（将来）
class GitHubAuthService implements AuthService {
  @override
  Future<bool> login(String credential) async {
    // GitHub OAuth実装
  }
  // ...
}

// アプリ全体で使用
class AuthProvider {
  static AuthService get instance {
    // 環境変数や設定で切り替え
    return SimpleAuthService(); // 最初はこれ
    // return GitHubAuthService(); // 後で切り替え
  }
}
```

### GitHub OAuth移行時の追加実装

#### 1. Firebase設定（無料）

```bash
# Firebase CLIインストール
npm install -g firebase-tools

# Firebaseプロジェクト作成
firebase login
firebase init hosting
```

#### 2. GitHub OAuth App登録

```
GitHub Settings > Developer settings > OAuth Apps > New OAuth App

Application name: Schedule Manager
Homepage URL: https://your-username.github.io/jleague_watching_calendar
Authorization callback URL: https://your-username.github.io/__/auth/handler
```

#### 3. Firebase設定にGitHub情報追加

```javascript
// Firebase Console > Authentication > Sign-in method > GitHub
// GitHub OAuth AppのClient IDとSecretを設定
```

### GitHub OAuth後の追加機能（オプション）

**自動バックアップをGitHub Gistに:**

```dart
import 'package:http/http.dart' as http;

class GistBackupService {
  final String accessToken;

  GistBackupService(this.accessToken);

  Future<void> backup(String jsonData) async {
    final response = await http.post(
      Uri.parse('https://api.github.com/gists'),
      headers: {
        'Authorization': 'token $accessToken',
        'Content-Type': 'application/json',
      },
      body: jsonEncode({
        'description': 'Schedule backup',
        'public': false,
        'files': {
          'schedule_backup.json': {'content': jsonData}
        }
      }),
    );
  }

  Future<String?> restore(String gistId) async {
    final response = await http.get(
      Uri.parse('https://api.github.com/gists/$gistId'),
      headers: {'Authorization': 'token $accessToken'},
    );

    if (response.statusCode == 200) {
      final data = jsonDecode(response.body);
      return data['files']['schedule_backup.json']['content'];
    }
    return null;
  }
}
```

### タイムライン例

| フェーズ | 期間目安 | 内容 |
|---------|---------|------|
| フェーズ1 | 1-2日 | 簡易認証実装 + プロジェクトセットアップ |
| フェーズ2 | 1-2週間 | コア機能開発（予定管理、メモ、検索） |
| フェーズ3 | 2-3日 | GitHub OAuth移行 + Gist連携 |

### セキュリティの注意点

**簡易認証期間中:**
- ✅ 開発・テスト用と割り切る
- ✅ 本番デプロイ前にGitHub OAuthに切り替える
- ⚠️ 機密情報は入力しない
- ⚠️ URLを他人に教えない

### まとめ

この段階的アプローチは理想的です：

1. **フェーズ1**: 簡易認証で素早くプロトタイプ
2. **フェーズ2**: コア機能に集中して開発
3. **フェーズ3**: 安全なGitHub OAuthに移行

**次のステップ:** Flutter Webプロジェクトのセットアップから始めますか？それとも、簡易認証の実装から詳しく見ていきますか?

---

## 質問

ありがとう。
現在の方針としてはまず以下で初めてい見るに倒れつつあるかと認識しています
・GitHub PagesでPWAのアプリを配布
・認証は簡易なものから初め、最終的にはGitHub OAuth
・データは内部ストレージにおくとこから始め、GitHub OAuthの連携時にはGistへのデータ保存

---

## 回答

完璧です！方針が明確に固まりましたね。整理すると：

### 確定した開発方針

#### フェーズ1: プロトタイプ
- **配布**: GitHub Pages（PWA）
- **認証**: 簡易パスワード認証（SHA-256ハッシュ比較）
- **データ**: ブラウザ内部ストレージ（IndexedDB/Hive）
- **バックアップ**: JSONエクスポート/インポート

#### フェーズ2: 本番化
- **配布**: GitHub Pages（継続）
- **認証**: GitHub OAuth
- **データ**: ローカル + GitHub Gist（自動バックアップ）
- **バックアップ**: Gist + 手動エクスポート

### 技術スタック

```
フロントエンド: Flutter Web
ホスティング: GitHub Pages
ストレージ: Hive (IndexedDB wrapper)
認証（初期）: SHA-256 + SharedPreferences
認証（最終）: Firebase Auth + GitHub OAuth
バックアップ: GitHub Gist API
```

### 次のステップ

開発を始めるにあたって：

1. **Flutter Webプロジェクトのセットアップ**
2. **PWA設定（manifest.json, service worker）**
3. **簡易認証の実装**
4. **データモデル設計**
5. **基本的なUI実装**

どこから始めますか？

- **A**: 今すぐプロジェクトをセットアップして、基本構造を作る
- **B**: まずデータモデルとUI設計を相談してから実装に入る
- **C**: 別の確認事項がある

準備ができていれば、`jleague_watching_calendar` ディレクトリでFlutterプロジェクトを作成するところから始められます。

---

## 決定事項（更新）

### 開発方針
1. **配布方法**: GitHub Pages（PWA）
2. **認証**:
   - 初期: 簡易パスワード認証（SHA-256ハッシュ比較）
   - 最終: GitHub OAuth
3. **データ保存**:
   - 初期: ブラウザ内部ストレージ（IndexedDB/Hive）
   - 最終: ローカル + GitHub Gist（自動バックアップ）
4. **バックアップ**: 手動エクスポート/インポート（JSON）

### 技術スタック
- **フロントエンド**: Flutter Web
- **ホスティング**: GitHub Pages
- **ストレージ**: Hive (IndexedDB wrapper)
- **認証（初期）**: SHA-256 + SharedPreferences
- **認証（最終）**: Firebase Auth + GitHub OAuth
- **バックアップ**: GitHub Gist API

### 開発フェーズ
1. **フェーズ1**: プロトタイプ（簡易認証 + ローカルストレージ）
2. **フェーズ2**: コア機能開発（予定管理、メモ、検索）
3. **フェーズ3**: GitHub OAuth移行 + Gist連携

### 次のステップ
- Flutter Webプロジェクトのセットアップ
- PWA設定（manifest.json, service worker）
- 簡易認証の実装
- データモデル設計
- 基本的なUI実装

---
